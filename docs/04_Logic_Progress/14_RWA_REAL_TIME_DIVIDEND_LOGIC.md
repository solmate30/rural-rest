# RWA Real-time Dividend Distribution Logic (DeFi Staking Model)

이 문서는 Rural Rest의 RWA 솔라나 스마트 컨트랙트가 수백, 수천 명의 투자자에게 **단일 트랜잭션**으로 **발생 즉시 수익금을 분배**할 수 있게 해주는 핵심 알고리즘 구조입니다.

전통적인 방식(각 유저를 순회하며 개별 송금)은 가스비와 트랜잭션 한계로 인해 블록체인에서 불가능합니다. 따라서 **DeFi 프로토콜(예: MasterChef, Synthetix Reward Pool)에서 널리 쓰이는 Reward Debt(수령 부채) 수학 모델**을 도입하여 해결합니다.

---

## 1. 핵심 개념 (Core Concepts)

### A. 글로벌 상태 변수 (Pool State)
숙박 완료에 따른 순수익(USDC)이 컨트랙트에 입금될 때마다, 컨트랙트는 **개별 유저의 정보를 전혀 건드리지 않고 오직 아래의 글로벌 값 한 개만 업데이트** 합니다.

*   `acc_dividend_per_share` (누적 주당 배당액, DPS)
    *   **공식:** `New DPS = Old DPS + (이번에 추가된 배당금 / 총 발행 토큰 수)`
    *   **의미:** "만약 내가 이 숙소 런칭 첫날부터 토큰 1개를 계속 들고 있었다면 지금껏 받을 수 있었던 총액"

### B. 개인 상태 변수 (User State)
각 투자자(User)는 자신의 투자 내역(InvestmentRecord)에 자신의 지분 크기와 더불어, `reward_debt`(수령 부채)라는 영수증 값을 기록해둡니다.

*   `reward_debt` (수령 부채)
    *   **공식:** `나의 토큰 보유량 * 그 시점의 글로벌 DPS`
    *   **의미:** "이 투자자는 이 시점까지는 배당금을 이미 가져간 것으로 간주한다." (즉, 이전에 쌓인 배당금은 내 몫이 아님을 수학적으로 증명)

---

## 2. 발생 트리거 및 흐름 (Lifecycle & Flow)

### Step 1. 토큰 구매 (Invest)
유저 A가 토큰 10개를 신규 구매합니다. (현재 글로벌 DPS: 5 USDC)
*   **유저 A의 초기 상태:**
    *   `보유 토큰 수 = 10`
    *   `reward_debt = 10 * 5 = 50`
*   *(의미: 유저 A는 지금 막 들어왔으므로, 이 시점 이전에 쌓인 토큰 10개어치의 배당금 50 USDC는 가져갈 권리가 없음을 기록합니다.)*

### Step 2. 숙박 매출 발생 (Add Stay Revenue) - **실시간 분배 액션**
숙박객이 결제를 완료하여 순수익 1,000 USDC가 배당 풀에 입금됩니다. (현재 해당 숙소의 총 발행 토큰: 100개)
*   **글로벌 상태 업데이트:**
    *   `추가되는 DPS = 1000 / 100 = 10 USDC`
    *   `새로운 글로벌 DPS = 5 (기존) + 10 = 15 USDC`
*   *(의미: 컨트랙트 안의 DPS 숫자가 5에서 15로 바뀌는 단 1번의 덧셈 연산만 일어납니다. 유저 수백 명의 원장을 업데이트하지 않아도 됩니다.)*

### Step 3. 실시간 배당금 청구 (Claim Dividend)
유저 A가 Rural Rest 앱을 열고 자신의 미수령 배당금을 확인 후 `Claim(수령)` 버튼을 누릅니다.
*   **배당금 계산 공식:** `(나의 보유 토큰 수 * 현재 글로벌 DPS) - 나의 reward_debt`
*   **유저 A 계산:** `(10 * 15) - 50 = 150 - 50 = 100 USDC`
*   **결과:** 
    1.  유저 A의 지갑으로 100 USDC가 전송됩니다.
    2.  유저 A의 `reward_debt`를 오늘 기준으로 초기화합니다. `(10 * 15 = 150)`
*   *(의미: 이후에 추가적인 매출이 없다면, 다시 청구해도 (10*15) - 150 = 0 이 되어 중복 수령이 방지됩니다.)*

---

## 3. 정밀도 처리 (Precision Handling)

### 문제: 정수 나눗셈 손실

Solana/Anchor 스마트 컨트랙트는 Rust로 작성되며, **부동소수점(float)을 사용하지 않습니다.** 따라서 DPS를 그대로 정수로 계산하면 나눗셈 과정에서 소수점 이하가 잘려(truncation) 수익금이 소실됩니다.

**예시 (정밀도 배수 없이):**
- 총 발행 토큰: 1,000,000개 / 추가 매출: 100 USDC
- `added_DPS = 100 / 1,000,000 = 0` (정수 나눗셈으로 전액 소실)

### 해결: 정밀도 배수 (Precision Multiplier)

DPS를 저장하고 계산할 때 **큰 상수 배수를 곱해 정수 공간에서 소수점을 표현**합니다. Rural Rest 컨트랙트에서는 `1e12` (1조)를 사용합니다.

```
PRECISION = 1_000_000_000_000  // 1e12
```

**수정된 공식:**

| 연산 | 기존 공식 | 정밀도 적용 공식 |
|---|---|---|
| DPS 업데이트 | `DPS += revenue / total_tokens` | `DPS += (revenue * PRECISION) / total_tokens` |
| 미수령 배당금 계산 | `pending = (tokens * DPS) - reward_debt` | `pending = (tokens * DPS / PRECISION) - reward_debt` |
| reward_debt 세팅 | `reward_debt = tokens * DPS` | `reward_debt = tokens * DPS / PRECISION` |

**수정된 예시 (총 발행 토큰 1,000,000개, 매출 100 USDC):**
- `added_DPS = (100 * 1_000_000_000_000) / 1_000_000 = 100_000_000` (정확히 보존)
- 유저가 토큰 1개 보유 시 pending = `(1 * 100_000_000) / 1_000_000_000_000 = 0.0001 USDC` (정확)

> **주의:** USDC는 소수점 6자리를 사용하므로, 컨트랙트 내부에서 USDC 단위는 `lamport` 대신 `micro-USDC (1 USDC = 1_000_000)`로 처리합니다. 최종 출금 시 이 단위를 기준으로 전송합니다.

---

## 4. 이 모델의 기술적 장점 (Why this model?)

1.  **O(1) 의 트랜잭션 비용 (Constant Time Complexity)**
    *   숙박 1건이 발생했을 때, 투자자가 10명이든 10만 명이든 상관없이 **"글로벌 변수(DPS) 1번 덧셈"** 이라는 완벽히 파악 가능한 최저 비용(가스비)만 소비됩니다. 솔라나의 Compute Unit 한도(Limit)초과 에러에서 완전히 자유롭습니다.
2.  **완전한 실시간성 (True Real-time)**
    *   배치(Batch), 스케줄러(Cron) 같은 백엔드의 무거운 작업이나, "매주 정산" 같은 유예기간이 필요하지 않습니다. 숙박 예약 즉시 돈이 컨트랙트에 쏴지고(Push), 유저는 원할 때 1초 단위로 찾아갈(Pull) 수 있습니다.
3.  **높은 스케일러빌리티와 2차 시장 지원**
    *   토큰을 사고 팔거나 추가 구매하는 일이 발생해도, 해당 순간에 발생할 수 있는 "미수령 배당금 선지급(Harvest)"과 "새로운 `reward_debt` 세팅"만 해주면 모든 수학적 무결성이 깨지지 않고 유지됩니다. (향후 토큰 거래소 연동 시 필수 조건)

이 로직을 바탕으로 `anchor` 스마트 컨트랙트를 작성하겠습니다.
